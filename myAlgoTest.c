#pragma config(Sensor, S1, colorSensor, sensorEV3_Color)
#pragma config(Sensor, S4, ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Motor, motorA, rightMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorC, pinchMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, leftMotor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int forwardSpeed = 40;
const int defSpeed = 30;
const int lowRed = 10;
const int highRed = 14;
const int highGreen = 22;
const int turnLimit = 240;
int redVal;
int greenVal;
int blueVal;
bool finish = false;
bool lastLeft = false;

//Movement functions
void forward()
{
    setMotorSpeed(leftMotor, -forwardSpeed);
    setMotorSpeed(rightMotor, -forwardSpeed);
}

void reverse() {
	setMotorSpeed(leftMotor, 90);
	setMotorSpeed(rightMotor, 90);
}

void stopMoving()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void rotateRight()
{
	setMotorSpeed(leftMotor, -defSpeed);
	setMotorSpeed(rightMotor, defSpeed);
}

void rotateLeft()
{
 	setMotorSpeed(leftMotor, defSpeed);
 	setMotorSpeed(rightMotor, -defSpeed);
}

//Line search
void findLine()
{
    int redVal;
    int greenVal;
    int blueVal;

    stopMoving();
    int motorEnc;

    // turned left last time
    if (lastLeft)
    {
        // turn left
        resetMotorEncoder(rightMotor);
        motorEnc = getMotorEncoder(rightMotor);
        rotateLeft();
        while (motorEnc < turnLimit)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                stopMoving();
                lastLeft = true;
                return;
            }
            motorEnc = getMotorEncoder(rightMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
        // turn right
        resetMotorEncoder(leftMotor);
        motorEnc = getMotorEncoder(leftMotor);
        rotateRight();
        while (motorEnc < turnLimit * 2)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                stopMoving();
                lastLeft = false;
                return;
            }
            motorEnc = getMotorEncoder(leftMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
        // turn left back to straight
        resetMotorEncoder(rightMotor);
        motorEnc = getMotorEncoder(rightMotor);
        rotateLeft();
        while (motorEnc < turnLimit)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                stopMoving();
                lastLeft = true;
                return;
            }
            motorEnc = getMotorEncoder(rightMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
    }
    else
    {
        // turn right
    		resetMotorEncoder(leftMotor);
        motorEnc = getMotorEncoder(leftMotor);
        rotateRight();
        while (motorEnc < turnLimit)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                lastLeft = false;
                stopMoving();
                return;
            }
            motorEnc = getMotorEncoder(leftMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
        // turn left
        resetMotorEncoder(rightMotor);
        motorEnc = getMotorEncoder(rightMotor);
        rotateLeft();
        while (motorEnc < turnLimit * 2)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                lastLeft = true;
                stopMoving();
                return;
            }
            motorEnc = getMotorEncoder(rightMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
        // turn right back to straight
        resetMotorEncoder(leftMotor);
        motorEnc = getMotorEncoder(leftMotor);
        rotateRight();
        while (motorEnc < turnLimit)
        {
            getColorRGB(colorSensor, redVal, greenVal, blueVal);
            if (redVal <= lowRed)
            {
                lastLeft = false;
                stopMoving();
                return;
            }
            motorEnc = getMotorEncoder(leftMotor);
            if (motorEnc < 0)
            {
                motorEnc *= -1;
            }
        }
    }
    // if not found, stop
    stopMoving();
    finish = true;
}

//movement for Blue behavior
void turnBack() {
	reverse();
	wait1Msec(200);
	int motorEnc;
	resetMotorEncoder(leftMotor);
  motorEnc = getMotorEncoder(leftMotor);
	rotateRight();
	while (motorEnc < 400) {
		motorEnc = getMotorEncoder(leftMotor);
		if (motorEnc < 0)
    {
    	motorEnc *= -1;
   	}
		wait1Msec(10);
	}
}

//Object processing
void processObject() {
	getColorRGB(colorSensor, redVal, greenVal, blueVal);
	//check if is on the line
	if (redVal <= highRed) {
		findLine();
	}

	//color check
	if (greenVal >= highGreen) {
		//is Green: move the obstacle
		//move towards object
		forward();
		wait1Msec(300);
		stopMoving();
		
		//close claw
		setMotorSpeed(pinchMotor, -90);
		wait1Msec(1000);
		setMotorSpeed(pinchMotor, 0);
		
		//turn to the opposite of last turn
		int motorEnc;
		if (lastLeft) {
			resetMotorEncoder(leftMotor);
  		motorEnc = getMotorEncoder(leftMotor);
			rotateRight();
			while (motorEnc < 300) {
				motorEnc = getMotorEncoder(leftMotor);
				if (motorEnc < 0)
    		{
    			motorEnc *= -1;
   			}
				wait1Msec(10);
			}
		} else {
			resetMotorEncoder(rightMotor);
  		motorEnc = getMotorEncoder(rightMotor);
			rotateLeft();
			while (motorEnc < 300) {
				motorEnc = getMotorEncoder(rightMotor);
				if (motorEnc < 0)
    		{
    			motorEnc *= -1;
   			}
				wait1Msec(10);
			}
		}
		stopMoving();
		
		//move forward
		forward();
		wait1Msec(2000);
		stopMoving();
		
		//open claw
		setMotorSpeed(pinchMotor, 90);
		wait1Msec(1500);
		setMotorSpeed(pinchMotor, 0);
		
		//reverse
		reverse();
		wait1Msec(1000);
		
		//turn to the left
		if (!lastLeft) {
			resetMotorEncoder(leftMotor);
  		motorEnc = getMotorEncoder(leftMotor);
			rotateRight();
			while (motorEnc < 200) {
				motorEnc = getMotorEncoder(leftMotor);
				if (motorEnc < 0)
    		{
    			motorEnc *= -1;
   			}
				wait1Msec(10);
			}
		} else {
			resetMotorEncoder(rightMotor);
  		motorEnc = getMotorEncoder(rightMotor);
			rotateLeft();
			while (motorEnc < 200) {
				motorEnc = getMotorEncoder(rightMotor);
				if (motorEnc < 0)
    		{
    			motorEnc *= -1;
   			}
				wait1Msec(10);
			}
		}
		stopMoving();
	} else {
		//is Blue: turn back
		turnBack();
	}

}

task main()
{A
    float distance;

    while (!finish)
    {
        distance = getUSDistance(ultrasonicSensor);
        if (distance <= 10)
        {
        	processObject();
        }
        
        getColorRGB(colorSensor, redVal, greenVal, blueVal);
        if (redVal >= highRed)
        {
            findLine();
        }
        forward();
        wait1Msec(40);
    }
}
