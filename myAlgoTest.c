#pragma config(Sensor, S1, colorSensor, sensorEV3_Color)
#pragma config(Sensor, S4, ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Motor, motorA, rightMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorC, pinchMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, leftMotor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
const int forwardSpeed = 40;
const int defSpeed = 30;
const int lowRed = 10;
const int highRed = 14;
const int highGreen = 22;
const int turnLimit = 260;
int redVal;
int greenVal;
int blueVal;
bool finish = false;
bool lastLeft = false;

//Movement functions
void forward()
{
	setMotorSpeed(leftMotor, -forwardSpeed);
	setMotorSpeed(rightMotor, -forwardSpeed);
}

void reverse() {
	setMotorSpeed(leftMotor, 90);
	setMotorSpeed(rightMotor, 90);
}

void stopMoving()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void rotateRight()
{
	setMotorSpeed(leftMotor, -defSpeed);
	setMotorSpeed(rightMotor, defSpeed);
}

void rotateLeft()
{
	setMotorSpeed(leftMotor, defSpeed);
	setMotorSpeed(rightMotor, -defSpeed);
}

void rotateLeftFor(int degrees) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	rotateLeft();
	while (motorEnc < degrees)
	{
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
	return false;
}

bool findLeftFor(int degrees) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	rotateLeft();
	while (motorEnc < degrees)
	{
		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal <= lowRed)
		{
			stopMoving();
			lastLeft = true;
			return true;
		}
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
	}
	return false;
}

void findRightFor(int degrees) {
	resetMotorEncoder(leftMotor);
	int motorEnc = getMotorEncoder(leftMotor);
	rotateRight();
	while (motorEnc < degrees)
	{
		motorEnc = getMotorEncoder(leftMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
}

bool findRightFor(int degrees) {
	resetMotorEncoder(leftMotor);
	int motorEnc = getMotorEncoder(leftMotor);
	rotateRight();
	while (motorEnc < degrees)
	{
		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal <= lowRed)
		{
			stopMoving();
			lastLeft = false;
			return true;
		}
		motorEnc = getMotorEncoder(leftMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
	}
	return false;
}

//Line search
void findLine()
{
	stopMoving();

	// turned left last time
	if (lastLeft)
	{
		// turn left
		if (findLeftFor(turnLimit)) {
			return;	
		}
		// turn right
		if (findRightFor(turnLimit * 2)) {
			return;	
		}
		// turn left back to straight
		rotateLeftFor(turnLimit);
	}
	else
	{
		// turn right
		if (findRightFor(turnLimit)) {
			return;	
		}
		// turn left
		if (findLeftFor(turnLimit * 2)) {
			return;
		}
		// turn right back to straight
		rotateRightFor(turnLimit);
	}
	// if not found, stop
	stopMoving();
	finish = true;
}

//movement for Blue behavior
void turnBack() {
	reverse();
	wait1Msec(150);
	rotateRightFor(400);
}

void beep() {
	playImmediateTone(169, 200);
}

//Object processing
void processObject() {
	//Pause and beep
	stopMoving();
	beep();
	wait1Msec(2000);

	getColorRGB(colorSensor, redVal, greenVal, blueVal);
	//check if robot is not on the line
	bool notOnLine = (redVal >= highRed);
	if (notOnLine) {
		findLine();
	}

	//color check
	bool isOnGreen = (greenVal >= highGreen);
	if (isOnGreen) {
		//Move the obstacle
		//move towards object
		forward();
		wait1Msec(300);
		stopMoving();

		//close claw
		setMotorSpeed(pinchMotor, -90);
		wait1Msec(1000);
		setMotorSpeed(pinchMotor, 0);

		//turn to the opposite of last turn (most likely to be away from the line and the track)
		if (lastLeft) {
			rotateRightFor(300);
			} else {
			rotateLeftFor(300);
		}
		stopMoving();

		//move forward
		forward();
		wait1Msec(2000);
		stopMoving();

		//open claw
		setMotorSpeed(pinchMotor, 90);
		wait1Msec(1500);
		setMotorSpeed(pinchMotor, 0);

		//reverse
		reverse();
		wait1Msec(1000);

		//turn to the left
		if (!lastLeft) {
			rotateLeftFor(200);
			} else {
			rotateRightFor(200);
		}
		stopMoving();

	}
	//Is Blue : turn back
	else {
		turnBack();
	}
}

task main()
{
	float distance;

	while (!finish)
	{
		distance = getUSDistance(ultrasonicSensor);
		if (distance <= 10)
		{
			processObject();
		}

		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal >= highRed)
		{
			findLine();
		}
		forward();
		wait1Msec(40);
	}
}
