#pragma config(Sensor, S1, ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4, gyro, sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor, motorA, rightMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, leftMotor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int Solver();
void goBackHome();
void GridInit();
void forward();
void turnLeft();
void turnRight();
void stopMoving();

typedef struct
{
	int NorthWall;
	int EastWall;
	int SouthWall;
	int WestWall;
} Cell;

Cell Grid[4][6];

// 0=North, 1=East, 2=South, 3=West
int RobotDirection = 0;
const int north = 0;
const int east = 1;
const int south = 2;
const int west = 3;

// Starting position
int StartPosRow = 0;
int StartPosCol = 4;

int CurrentPosRow = StartPosRow;
int CurrentPosCol = StartPosCol;

// Target position
int TargetPosRow = 3;
int TargetPosCol = 1;

int turnRightArr[] = {1, 2, 3, 0};
int turnLeftArr[] = {3, 0, 1, 2};
int reverseMagic[] = {2, 3, 0, 1};

const int colMove[] = {0, 1, 0, -1};
const int rowMove[] = {1, 0, -1, 0};

// Moves STACK
int turns[64];
int stackPt = 0;

// How far to move forward
const int forwardTime = 2300;

bool goHome = false;

void reverseMoves()
{
	for (int i = 0; i <= stackPt; i++)
	{
		if (turns[i] != -1)
		{
			turns[i] = reverseMagic[turns[i]];
		}
	}
}

void stackInit()
{
	for (int i = 0; i < 64; i++)
	{
		turns[i] = -1;
	}
}

void GridInit()
{
	for (int x = 0; x < 24; x++)
	{
		turns[x] = -1;
	}
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 6; j++)
		{
			Grid[i][j].NorthWall = 0;
			Grid[i][j].EastWall = 0;
			Grid[i][j].WestWall = 0;
			Grid[i][j].SouthWall = 0;
		}
	}
}

int Solver()
{
	float distance;

	turnRight();
	distance = getUSDistance(ultrasonicSensor);
	wait1Msec(150);

	if (distance > 12)
	{
		forward();
	}
	else
	{
		for (int x = 0; x < 3; x++)
		{
			turnLeft();
			wait1Msec(150);
			if (getUSDistance(ultrasonicSensor) > 12)
			{
				forward();
				break;
			}
		}
	}
	return 0;
}

void stopMoving()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void wallBump()
{
	if (SensorValue(ultrasonicSensor) <= 15)
	{
		setMotorSpeed(leftMotor, 28);
		setMotorSpeed(rightMotor, 28);
		wait1Msec(1500);
		setMotorSpeed(leftMotor, -28);
		setMotorSpeed(rightMotor, -28);
		wait1Msec(600);
		stopMoving();
	}
}

void forward()
{
	if (!goHome)
	{
		if (stackPt == 0 || abs(turns[stackPt - 1] - RobotDirection) != 2)
		{
			turns[stackPt] = RobotDirection;
			stackPt++;
		}
		else
		{
			turns[stackPt - 1] = -1;
			stackPt--;
		}
	}

	CurrentPosCol += colMove[RobotDirection];
	CurrentPosRow += rowMove[RobotDirection];

	setMotorSpeed(leftMotor, 28);
	setMotorSpeed(rightMotor, 29);

	wait1Msec(forwardTime);
	stopMoving();
	wallBump();
}

void rotateRight()
{
	RobotDirection = turnRightArr[RobotDirection];
	resetGyro(gyro);
	while (SensorValue(gyro) <= 80)
	{
		setMotorSpeed(leftMotor, 28);
		setMotorSpeed(rightMotor, -28);
	}
}

void rotateLeft()
{
	RobotDirection = turnLeftArr[RobotDirection];
	resetGyro(gyro);
	while (SensorValue(gyro) >= -84)
	{
		setMotorSpeed(leftMotor, -28);
		setMotorSpeed(rightMotor, 28);
	}
}

void turnRight()
{
	rotateRight();
	stopMoving();
	wallBump();
	resetGyro(gyro);
}

void turnLeft()
{
	rotateLeft();
	stopMoving();
	wallBump();
	resetGyro(gyro);
}

void goBackHome()
{
	reverseMoves();
	goHome = true;
	rotateRight();
	rotateRight();
	stackPt -= 1;
	// Keep looping until the stack is empty
	while (stackPt >= 0)
	{
		if (turns[stackPt] == RobotDirection)
		{
			forward();
			stackPt -= 1;
		}
		else
		{
			int currDir = turns[stackPt];
			// Crazy switch block
			switch (RobotDirection)
			{
			case north:
				switch (currDir)
				{
				case east:
					rotateRight();
					break;
				case west:
					rotateLeft();
					break;
				}
				break;
			case west:
				switch (currDir)
				{
				case north:
					rotateRight();
					break;
				case south:
					rotateLeft();
					break;
				}
				break;
			default:
				switch (currDir - RobotDirection)
				{
				case 1:
					rotateRight();
					break;
				case -1:
					rotateLeft();
					break;
				}
				break;
			}
		}
	}
}

task main()
{
	GridInit();
	setSoundVolume(2);
	playImmediateTone(300, 200);
	wait1Msec(2000);
	stackInit();
	while ((CurrentPosRow != TargetPosRow) || (CurrentPosCol != TargetPosCol))
	{
		Solver();
	}
	playImmediateTone(300, 200);
	wait1Msec(2000);
	goBackHome();
}
