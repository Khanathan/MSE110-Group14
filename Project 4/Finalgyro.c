#pragma config(Sensor, S1,     ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct
{
	int NorthWall;
	int EastWall;
	int SouthWall;
	int WestWall;
} Cell;

Cell Grid[4][6];

// Start Facing North
int RobotDirection = 0; // 0=North, 1=East, 2=South, 3=West
int north = 0;
int east = 1;
int south = 2;
int west = 3;
// Start in the 0,0 Cell
int StartPosRow = 0; // Starting position
int StartPosCol = 4;

int CurrentPosRow = StartPosRow; // Starting position
int CurrentPosCol = StartPosCol;

int TargetPosRow = 3;
int TargetPosCol = 1;

int turnRightArr[] = {1, 2, 3, 0};
int turnLeftArr[] = {3, 0, 1, 2};
int reverseMagic[] = {2, 3, 0, 1};

const int colMove[] = {0, 1, 0, -1};
const int rowMove[] = {1, 0, -1, 0};

//STACK
int turns[64];
int stackPt = 0;

void reverseMoves() {
	for (int i = 0; i <= stackPt; i++) {
		turns[i] = reverseMagic[turns[i]];
	}
}

void stackInit() {
	for (int i = 0; i < 64; i++) {
		turns[i] = -1;
	}	
}

int Solver();
void goBackHome();
void GridInit();
void forward();
void turnLeft();
void turnRight();
void stopMoving();


void GridInit()
{
		for (int x = 0; x < 24; x++){
			turns[x] =-1 ;
		}
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 6; j++)
        {
            Grid[i][j].NorthWall = 0;
            Grid[i][j].EastWall = 0;
            Grid[i][j].WestWall = 0;
            Grid[i][j].SouthWall = 0;
        }
    }
}

//How far to move forward
const int forwardTime = 2300;
bool goHome = false;

int Solver()
{
    float distance;

		turnRight();
		distance = getUSDistance(ultrasonicSensor);
    wait1Msec(500);
    
		if (distance > 10)
		{
			forward();
		}
		else
		{
    	for (int x = 0; x < 3; x++){
      	turnLeft();
        wait1Msec(500);
        if (getUSDistance(ultrasonicSensor) > 10)
        {
        	forward();
         	break;
				}
    	}
		}
		return 0;
}

void wallBump() {
	if(SensorValue(ultrasonicSensor) <= 13){
    setMotorSpeed(leftMotor, 28);
		setMotorSpeed(rightMotor, 28);
		wait1Msec(650);			
    setMotorSpeed(leftMotor, -28);
		setMotorSpeed(rightMotor, -28);
		wait1Msec(400);
		stopMoving();
	}	
}

void forward()
{
	if(!goHome){
  	if (stackPt == 0 || abs(turns[stackPt-1] - RobotDirection) != 2 )
    {
    	turns[stackPt] = RobotDirection;
      stackPt++;
    }
    else
    {
    	turns[stackPt-1] = -1;
      stackPt--;
    }
  }
  
  CurrentPosCol += colMove[RobotDirection];
	CurrentPosRow += rowMove[RobotDirection];
	
	setMotorSpeed(leftMotor, 28);
	setMotorSpeed(rightMotor, 28);

  wait1Msec(forwardTime);
  stopMoving();
  wallBump();
}

void stopMoving() {
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}
/*
/void turnAdjust() 
{
	stopMoving();
	if (getUSDistance(ultrasonicSensor) > 8)
  {
        setMotorSpeed(leftMotor, 28);
				setMotorSpeed(rightMotor, 28);
				wait1Msec(500);
				stopMoving();

	}
	if(SensorValue(ultrasonicSensor) <= 6){
    		//setMotorSpeed(leftMotor, -28);
				//setMotorSpeed(rightMotor, -28);
				//wait1Msec(100);
				stopMoving();
    }
}
*/
void turnRight()
{
    RobotDirection = turnRightArr[RobotDirection];
    resetGyro(gyro);
    while(SensorValue(gyro) <= 80){
	    setMotorSpeed(leftMotor, 28);
	    setMotorSpeed(rightMotor, -28);
	    wait1Msec(10);
		}
		wallBump();
}

void turnLeft()
{
    RobotDirection = turnLeftArr[RobotDirection];
    resetGyro(gyro);
		while(SensorValue(gyro) >= -70){
	    setMotorSpeed(leftMotor, -28);
	    setMotorSpeed(rightMotor, 28);
	    wait1Msec(10);
		}
		wallBump();
}

//pop()

void goBackHome()
{
	reverseMoves();
	goHome = true;
    turnRight();
    turnRight();
    forward();
    for(int x = stackPt; x < -1; x--){
    	displayCenteredTextLine(5, "%d",RobotDirection-turns[x]);
        if (turns[x] != -1){
            if ((RobotDirection-turns[x]) == 2){
                forward();
            }
            else if ((RobotDirection-turns[x]) == 1){
                turnLeft();
            }
            else{
                turnRight();
            }
        }
    }
}

task main()
{
		GridInit();
		setSoundVolume(2);
    playImmediateTone(300, 200);
    wait1Msec(2000);
    stackInit();
		while ((CurrentPosRow != TargetPosRow) || (CurrentPosCol != TargetPosCol))
        {
				Solver();
		}
		
		playImmediateTone(300, 200);
		wait1Msec(2000);
		goBackHome();
}
