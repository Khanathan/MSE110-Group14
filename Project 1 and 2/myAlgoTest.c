#pragma config(Sensor, S1, colorSensor, sensorEV3_Color)
#pragma config(Sensor, S4, ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Motor, motorA, rightMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorC, pinchMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, leftMotor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

//IF THERE ARE LINES ON THE TRACK THAT ARE CLOSE TO EACHOTHER, DECREASE THE SEARCH SWEEP ANGLE IN THE FIND FUNCTION TO MAKE SURE IT DOESNT SWEEP INTO
//A FAR-AWAY LINE

const int detectDistance = 17;
const int forwardSpeed = 40;
const int defSpeed = 25;
const int lowRed = 10;
const int highRed = 15;
const int highGreen = 20;
const int turnLimit = 230; //SEARCH SWEEP ANGLE
int redVal;
int greenVal;
int blueVal;
bool finish = false;
bool lastLeft = false;

//Movement functions
void forward()
{
	setMotorSpeed(leftMotor, -forwardSpeed);
	setMotorSpeed(rightMotor, -forwardSpeed);
}

void forwardFor(int deg) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	forward();
	while (motorEnc < deg)
	{
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
}

void reverse() {
	setMotorSpeed(leftMotor, 90);
	setMotorSpeed(rightMotor, 90);
}

void reverseFor(int deg) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	reverse();
	while (motorEnc < deg)
	{
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
}

void stopMoving()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void rotateRight()
{
	setMotorSpeed(leftMotor, -defSpeed);
	setMotorSpeed(rightMotor, defSpeed);
}

void rotateLeft()
{
	setMotorSpeed(leftMotor, defSpeed);
	setMotorSpeed(rightMotor, -defSpeed);
}

void rotateLeftFor(int degrees) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	rotateLeft();
	while (motorEnc < degrees)
	{
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
}

bool findLeftFor(int degrees) {
	resetMotorEncoder(rightMotor);
	int motorEnc = getMotorEncoder(rightMotor);
	rotateLeft();
	while (motorEnc < degrees)
	{
		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal <= lowRed)
		{
			stopMoving();
			lastLeft = true;
			return true;
		}
		motorEnc = getMotorEncoder(rightMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
	}
	return false;
}

void rotateRightFor(int degrees) {
	resetMotorEncoder(leftMotor);
	int motorEnc = getMotorEncoder(leftMotor);
	rotateRight();
	while (motorEnc < degrees)
	{
		motorEnc = getMotorEncoder(leftMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
		wait1Msec(10);
	}
}

bool findRightFor(int degrees) {
	resetMotorEncoder(leftMotor);
	int motorEnc = getMotorEncoder(leftMotor);
	rotateRight();
	while (motorEnc < degrees)
	{
		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal <= lowRed)
		{
			stopMoving();
			lastLeft = false;
			return true;
		}
		motorEnc = getMotorEncoder(leftMotor);
		if (motorEnc < 0)
		{
			motorEnc *= -1;
		}
	}
	return false;
}

//LINE SEARCH FUNCTION
void findLine()
{
	stopMoving();

	// turned left last time
	if (lastLeft)
	{
		// turn left
		if (findLeftFor(turnLimit)) {
			return;	
		}
		// turn right
		if (findRightFor(turnLimit * 2)) {
			return;	
		}
		// turn left back to straight
		rotateLeftFor(turnLimit * 1.2);
	}
	else
	{
		// turn right
		if (findRightFor(turnLimit)) {
			return;	
		}
		// turn left
		if (findLeftFor(turnLimit * 2)) {
			return;
		}
		// turn right back to straight
		rotateRightFor(turnLimit * 1.2);
	}
	// if not found, stop
	stopMoving();
	finish = true;
}

//movement for Blue behavior
void turnBack() {
	reverse();
	wait1Msec(150);
	rotateRightFor(360);
}

void beep() {
	setSoundVolume(2);
	playImmediateTone(20, 200);
}

//Object processing
void processObject() {
	//Pause and beep
	stopMoving();
	beep();
	wait1Msec(2000);

	getColorRGB(colorSensor, redVal, greenVal, blueVal);
	//check if robot is not on the line
	bool notOnLine = (redVal >= highRed);
	if (notOnLine) {
		findLine();
	}

	//color check
	bool isOnGreen = (greenVal >= highGreen);
	if (isOnGreen) {
		//Move the obstacle
		//move towards object
		forward();
		wait1Msec(300);
		stopMoving();

		//close claw
		setMotorSpeed(pinchMotor, -90);
		wait1Msec(1500);
		setMotorSpeed(pinchMotor, 0);

		//turn to the opposite of last turn (most likely to be away from the line and the track)
		if (lastLeft) {
			rotateRightFor(240);
			} else {
			rotateLeftFor(240);
		}
		stopMoving();

		//move forward
		forwardFor(480);
		stopMoving();

		//open claw
		setMotorSpeed(pinchMotor, 90);
		wait1Msec(1500);
		setMotorSpeed(pinchMotor, 0);

		//reverse
		reverseFor(480);
		stopMoving();
		wait1Msec(1000);

		//turn to the left
		if (lastLeft) {
			rotateLeftFor(240);
			} else {
			rotateRightFor(240);
		}
		stopMoving();

	}
	//Is Blue : turn back
	else {
		turnBack();
	}
}

//mega
void mega() {
	int baseDur = 75;
	int baseNoteDur = 5;
	setSoundVolume(2);
	playTone(293, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	playTone(293, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	playTone(587, baseNoteDur * 2);
	wait1Msec(baseDur * 2);
	playTone(440, baseNoteDur * 2);
	wait1Msec(baseDur * 2);
	wait1Msec(baseDur * 1);
	playTone(415, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	wait1Msec(baseDur * 1);
	playTone(392, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	wait1Msec(baseDur * 1);
	playTone(349, baseNoteDur * 2);
	wait1Msec(baseDur * 2);
	playTone(293, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	playTone(349, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
	playTone(392, baseNoteDur * 1);
	wait1Msec(baseDur * 1);
}

task main()
{
	float distance;

	while (!finish)
	{
		distance = getUSDistance(ultrasonicSensor);
		if (distance <= detectDistance)
		{
			processObject();
		}

		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		if (redVal >= highRed)
		{
			findLine();
		}
		forward();
		wait1Msec(40);
	}
	stopMoving();
	mega();
	wait1Msec(2000);
}
