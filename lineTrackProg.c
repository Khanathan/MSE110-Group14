#pragma config(Sensor, S1,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S2,     ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          pinchMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Motor speeds
const int DEFAULT = 40; 
const int MAX = 100;
const int MIN = 20;

//negative value makes the robot move forward
//set speed for both wheels
void setSpeed(int speed) {
	setMotorSpeed(leftMotor, -speed);
	setMotorSpeed(rightMotor, -speed);
}

void turnLeft(int speed) {
	setMotorSpeed(leftMotor, -DEFAULT);
	setMotorSpeed(rightMotor, -speed);
}

void turnRight(int speed) {
	setMotorSpeed(leftMotor, -speed);
	setMotorSpeed(rightMotor, -DEFAULT);
}

//move forward at default speed
void forward() {
	setSpeed(-DEFAULT);
}

//move backwards at default speed
void backward() {
	setSpeed(DEFAULT);
}

void stopMoving() {
	setSpeed(0);
}

//turn on brake mode for both wheels
void brakeMode() {
	setMotorBrakeMode(leftMotor, motorBrake);
	setMotorBrakeMode(rightMotor, motorBrake);
}

//function for testing
void test() {
	forward();
	sleep(500);
	turnRight(70);
	sleep(1000);
	forward();
	turnLeft(70);
	sleep(1000);
	stopMoving();
}

//Green mode

//Blue mode

//PID setup
const float KP = 1.0;
const float KI = 0.1;
const float KD = 0.2;
const int setpoint = 10;

float pidCalc(float error, float integral, float derivative) {
	return KP * error + KI * integral + KD * derivative;
}


bool finish = false;

//STOP CONDITION : If robot turns for longer than it takes to make a 90 degree turn, finish = true


//MAIN FUNCTION
task main()
{
	int redVal;
	int greenVal;
	int blueVal;
	int distance;
	
	//PID variables
	float error = 0;
	float lastError = 0;
	float integral = 0;
	float derivative = 0;
	
	brakeMode();
	
	while (!finish) {
		getColorRGB(colorSensor, redVal, greenVal, blueVal);
		
		//more red = sensor away from the line = negative value -> turn left
		//less red = sensor more on top of the line = positive value -> turn right
		error = setpoint - redVal;
		integral += error;
		derivative = error - lastError;
		float pidVal = pidCalc(error, integral, derivative);
		
		if (error < 0) {
			int rightSpeed = DEFAULT - pidVal;
			if (rightSpeed < MIN) {
				rightSpeed = MIN;	
			} else if (rightSpeed > MAX) {
				rightSpeed = MAX;
			}
			turnLeft(rightSpeed);
		} else if (error == 0) {
			forward();
		} else {
			int leftSpeed = DEFAULT + pidVal;
			if (leftSpeed < MIN) {
				leftSpeed = MIN;	
			} else if (leftSpeed > MAX) {
				leftSpeed = MAX;
			}
			turnRight(leftSpeed);
		}
		
		lastError = error;
		
		wait1Msec(10);
	}	
}
